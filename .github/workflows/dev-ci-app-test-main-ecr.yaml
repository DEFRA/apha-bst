# dev app test - manual run
name: Dev Application Integration Test 
on:
  workflow_dispatch:
env:
  REPOSITORY: apha/bst
jobs:
  build-and-analyze:
    name: Build + Test + Sonar
    runs-on: windows-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.imgtag.outputs.image_tag }}
      should_push: ${{ steps.check_commit.outputs.should_push }}
    steps:
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: zulu
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref_name }}
          
      - name: Cache SonarQube Cloud packages
        uses: actions/cache@v4
        with:
          path: ~\sonar\cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache SonarQube Cloud scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: .\.sonar\scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
      - name: Install SonarQube Cloud scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          New-Item -Path .\.sonar\scanner -ItemType Directory
          dotnet tool update dotnet-sonarscanner --tool-path .\.sonar\scanner

      # 1️⃣ Compose image tag
      - name: Compose image tag
        id: imgtag
        shell: pwsh
        run: |
          $semver = "${{ steps.versioning.outputs.version }}"
          $runId = "${{ github.run_id }}"
          $last8 = $runId.Substring($runId.Length - 8)
          $imageTag = "v$semver-dev-$last8"
          Write-Host "Image tag: $imageTag"
          echo "image_tag=$imageTag" >> $env:GITHUB_OUTPUT

      # 2️⃣ Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_ENV_REGION }}
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ENV_ACCOUNT }}:role/${{ secrets.AWS_ENV_ROLE }}

      # 3️⃣ Login to Amazon ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4️⃣ Extract Docker metadata
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          flavor: |
            latest=false
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}
          tags: |
            type=raw,priority=800,value=${{ steps.imgtag.outputs.image_tag }}
          labels: |
            org.opencontainers.image.licenses=OGL-UK-3.0

      # 5️⃣ Build and push Docker image
      - name: Build and push Docker image
        shell: pwsh
        run: |
          $IMAGE_TAG = "${{ steps.imgtag.outputs.image_tag }}"
          $IMAGE_NAME = "${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}"

          $meta = ConvertFrom-Json '${{ steps.meta.outputs.json }}'
          $GIT_COMMIT = $meta.labels.'org.opencontainers.image.revision'
          $GIT_URL = $meta.labels.'org.opencontainers.image.source'
          $GIT_TITLE = $meta.labels.'org.opencontainers.image.title'
          $GIT_VERSION = $meta.labels.'org.opencontainers.image.version'
          $GIT_CREATED = $meta.labels.'org.opencontainers.image.created'
          $GIT_DESCRIPTION = $meta.labels.'org.opencontainers.image.description'
          $GIT_LICENSE = $meta.labels.'org.opencontainers.image.licenses'

          Write-Host "Building Docker image $IMAGE_NAME:$IMAGE_TAG"

          docker build `
            --file ./Dockerfile `
            --build-arg GIT_COMMIT="$GIT_COMMIT" `
            --label org.opencontainers.image.source="$GIT_URL" `
            --label org.opencontainers.image.revision="$GIT_COMMIT" `
            --label org.opencontainers.image.title="$GIT_TITLE" `
            --label org.opencontainers.image.version="$GIT_VERSION" `
            --label org.opencontainers.image.created="$GIT_CREATED" `
            --label org.opencontainers.image.description="$GIT_DESCRIPTION" `
            --label org.opencontainers.image.licenses="$GIT_LICENSE" `
            --tag "$IMAGE_NAME:$IMAGE_TAG" .

          Write-Host "Pushing Docker image..."
          docker push "$IMAGE_NAME:$IMAGE_TAG"

      # 6️⃣ Run container locally and test
      - name: Run container locally
        shell: pwsh
        run: |
          $image_tag = "${{ steps.imgtag.outputs.image_tag }}"
          docker build -t bst:$image_tag .
          Write-Host "Running local image: $image_tag"
          docker run -d --name test-container -p 8080:8080 -e ASPNETCORE_ENVIRONMENT=local bst:$image_tag

      - name: Wait for service to start
        shell: pwsh
        run: |
          Write-Host "Waiting for the service to start..."
          for ($i = 1; $i -le 10; $i++) {
            try {
              $status = (Invoke-WebRequest -Uri "http://localhost:8080/health" -UseBasicParsing -TimeoutSec 3).StatusCode
            } catch {
              $status = 0
            }
            Write-Host "HTTP Status: $status"
            if ($status -eq 200) {
              Write-Host "Service is healthy..."
              break
            }
            Write-Host "--- Last 5 log lines from container ---"
            docker logs test-container --tail 5
            Write-Host "---------------------------------------"
            Start-Sleep -Seconds 3
          }

      - name: Test application response
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri "http://localhost:8080/health" -UseBasicParsing

      - name: Cleanup container
        if: always()
        shell: pwsh
        run: |
          docker rm -f test-container